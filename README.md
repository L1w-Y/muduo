# 万字剖析muduo高性能网络库设计细节
## 📚 目录（Index）
- [一、前置知识](#一前置知识)
  - [2.1 阻塞/非阻塞 与 同步/异步](#21-阻塞非阻塞-与-同步异步)
      - [系统调用层面](#1-io系统调用层面)
      - [应用层面](#2-应用层面)
  - [2.2 五种IO模型](#22-五种IO模型)
      - [阻塞IO](#🟢阻塞io)
      - [非阻塞IO](#🟢非阻塞io)
      - [IO多路复用](#🟢io-多路复用)
      - [Select](#🟡select)
      - [Poll](#🟡poll)
      - [epoll](#🟡epoll)

- [Channel类](#channel类)

- [Poller类](#poller类)

- [EventLoop](#eventloop)
  - [三个类之间的协作](#三个类之间的协作)
  - [线程间通信](#线程间通信)
  - [共享资源？每个thread一个loop](#共享资源每个thread-一个loop)
  
## 一、前置知识

在进入正题之前，先聊一聊网络编程中一些重要的基本概念。

### 2.1 阻塞/非阻塞 与 同步/异步

`阻塞/非阻塞` 和 `同步/异步` 是两个不同维度的概念，我们分别在系统调用和应用层面上进行讨论：

---

### 1. IO系统调用层面

可以说正是因为底层 I/O 系统调用的行为（如`read`, `write`）存在这两种维度，才构成了上层进程通信模型的不同概念

#### - 🟢**Blocking vs Non-blocking**

描述的是**单个系统调用是否会使进程挂起**，以下以 `read()` 为例：

- **Blocking I/O**：  
  当调用 `read()` 后，如果内核缓冲区没有数据，内核会让该进程从「运行态」进入「睡眠态」。CPU 会调度执行其他进程。直到数据准备好并被复制到用户空间缓冲区后，内核才会唤醒该进程，`read()` 调用才会返回。这个过程中，进程是被阻塞的。

- **Non-blocking I/O**：  
  通过设置文件描述符的 `O_NONBLOCK` 标志实现。当用户进程调用 `read()` 时，如果内核缓冲区没有数据，系统调用会立即返回错误码。进程不会被阻塞，可以继续执行其他代码。通常用户会通过轮询方式在稍后再次尝试调用 `read()`。

#### -🟢**Synchronous vs Asynchronous**

描述的是**整个 I/O 操作（从发起请求到数据最终可用）是由谁来完成的**，以及结果是如何被通知给进程的。

- **Synchronous I/O**：  
  在同步 I/O 中，用户进程是发起 I/O 操作的主体，并且需要主动等待或查询 I/O 操作的结果。
  
  **🌟🌟在处理 IO 的时候，阻塞和非阻塞都是同步 IO。只有使用了特殊的 API 才是异步 IO🌟🌟** 
  - 阻塞 I/O 是同步的，因为进程通过阻塞来“等待”结果。
  - 非阻塞 I/O 也是同步的，因为进程需要通过反复轮询（polling）来“查询”操作是否完成。
  - I/O 多路复用（如 `select`, `epoll`）同样是同步的。虽然它们可以同时监听多个文件描述符，看起来像“异步”，但本质上 `select/epoll` 调用会阻塞进程以“等待”事件就绪。而且当事件返回后，数据还在内核缓冲区，用户进程仍需调用 `read()` 才能完成数据读取。因此整个 I/O 操作仍然是由用户主动完成的。

- **Asynchronous I/O**：  
  异步 I/O（如 `aio_read()`）中，用户进程发起请求后立即返回，可以做其他事。  
  内核会独立完成两个阶段：

  1. 等待数据准备好；
  2. 将数据从内核缓冲区拷贝到用户指定缓冲区。

  当这两个阶段完成后，内核通过 **信号** 或 **回调函数** 的方式通知用户进程：**数据已准备完毕且拷贝完成**。
  
  也就是说在异步io中，数据的读写是由内核帮助用户完成的。

---

### 2. 应用层面

在应用层面，这些概念更多地关注程序如何组织逻辑、等待结果、以及响应 I/O 的方式。

#### - 🟢**Blocking vs Non-blocking**

当你调用某个函数（通常是 I/O 相关，比如读取 socket、发请求等）时，当前线程是否被挂起等待结果返回。

*   **Blocking I/O**：
    当应用程序执行一个操作（比如调用一个函数去获取远程 API 数据，或查询数据库）时，如果该操作需要一些时间来完成，应用程序的当前执行线程会等待该操作返回结果后才能继续执行后续代码。
    如果某个任务耗时较长，整个应用（或至少是该线程）会显得 "卡顿" 或无响应。

    **例子**：一个传统的单线程 Web 服务器，当它为一个请求查询数据库时，它必须等待数据库返回结果，在此期间无法处理其他新的请求。

*   **Non-blocking I/O**：
    当应用程序执行一个操作时，该操作会立即返回，而不会等待其真正完成。应用程序可以继续执行其他任务。
    应用程序不会因为等待某个操作而被挂起，通常需要一种机制来稍后获取操作的结果，比如通过轮询检查状态，或者注册一个回调函数。

#### - 🟢**Synchronous vs Asynchronous**

在应用层面的同步和异步更多是描述 **整个操作或者业务逻辑的完成过程，是由调用方主动去完成，还是系统或框架异步地帮你完成后，通知你结果**。

*   **Synchronous I/O**：
    整个流程是顺序的，即使底层使用了非阻塞 I/O，如果应用逻辑设计成 "发起 -> 等待结果 -> 处理结果" 的串行模式，那么从应用行为上看它仍然是同步的。

*   **Asynchronous I/O**：
    在应用层面的一个处理逻辑，比如 A 向 B 请求调用一个网络 I/O 接口时（或者调用某个业务逻辑 API 接口时），向 B 传入请求的事件以及事件发生时通知的方式，A 就可以处理其它逻辑了。
    当 B 监听到事件处理完成后，会用事先约定好的通知方式，通知 A 处理结果。

    基于 reactor 的高性能网络框架多是采用这样的非阻塞 + 异步的设计模式，开发者注册相应事件和对应事件发生的回调函数，在监听到相应事件发生时，网络框架主动调用回调函数。
    虽然在网络库内部的事件监听和 I/O 读写操作时，采用的系统接口比如 `epoll_wait` 和 `recv()` 等等仍是同步的过程，但在上层应用层面的事件注册和处理逻辑是在异步执行。

---

### 2.2 五种IO模型
#### 🟢**阻塞IO**
![阻塞IO](res/阻塞io流程.gif)


#### 🟢**非阻塞IO**
#### 🟢**IO 多路复用**
  #### - 🟡**select**
  #### - 🟡**poll**
  #### - 🟡**epoll**
####  🟢**信号驱动**
####  🟢**异步**

## Channel类
       
设计思想 
        
作用     
        
代码细节 
        
## Poller类
作用    

设计方法，静态工厂

抽象接口

派生类构造

公共的DefaultPoller.cc

## eventloop

三个类之间的协作

线程间通信

共享资源？每个thread 一个loop

## Thread EventLoopThread EventLoopThreadPool

EventLoopThread的逻辑是
构造时将thread_(std::bind(&EventLoopThread::threadFunc,this),name)绑定，作为thread类的func_回调在调用startLoop时，调用thread_.start()，创建子线程用智能指针管理，然后子线程内部又调用func_（），也就是EventLoopThread的threadFunc()方法，在这个方法内创建了一个loop,调用外部传给的EventLoopThread的callback_，然后在这个threadFunc()回调中执行loop.loop();
两个问题
1.设计成这样复杂的回调逻辑是为什么
2.thread_(std::bind(&EventLoopThread::threadFunc,this),name)2.thread_(std::bind(&EventLoopThread::threadFunc,this),name)将类内部成员方法传给thread_，但是构造时是move,这样内成员方法不就是脱离对象实例在调用吗